<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/client/java/org/lassilos/color/client/ColorClient.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/client/java/org/lassilos/color/client/ColorClient.java" />
              <option name="originalContent" value="package org.lassilos.color.client;&#10;&#10;import net.fabricmc.api.ClientModInitializer;&#10;import net.fabricmc.fabric.api.client.event.lifecycle.v1.ClientTickEvents;&#10;import net.fabricmc.fabric.api.client.keybinding.v1.KeyBindingHelper;&#10;import net.fabricmc.fabric.api.client.rendering.v1.HudRenderCallback;&#10;import net.minecraft.client.MinecraftClient;&#10;import net.minecraft.client.gui.screen.Screen;&#10;import net.minecraft.client.option.KeyBinding;&#10;import net.minecraft.client.util.InputUtil;&#10;import net.minecraft.text.Text;&#10;import org.lwjgl.glfw.GLFW;&#10;import org.lwjgl.glfw.GLFWKeyCallback;&#10;&#10;import java.lang.reflect.Constructor;&#10;&#10;public class ColorClient implements ClientModInitializer {&#10;&#10;    private static KeyBinding KEY_SHOW_SCREEN;&#10;    // Try multiple plausible Axiom class names (UK/US spellings and picker variants)&#10;    private static final String[] AXIOM_SCREEN_CANDIDATES = new String[] {&#10;            &quot;com.moulberry.axiom.screen.CreativeColourScreen&quot;,&#10;            &quot;com.moulberry.axiom.screen.CreativeColorScreen&quot;,&#10;            &quot;com.moulberry.axiom.screen.BlockColourPickerScreen&quot;,&#10;            &quot;com.moulberry.axiom.screen.BlockColorPickerScreen&quot;,&#10;            &quot;com.moulberry.axiom.screen.CreativeColourPickerScreen&quot;,&#10;            &quot;com.moulberry.axiom.screen.CreativeColorPickerScreen&quot;&#10;    };&#10;&#10;    private String lastOverlayMessage = null;&#10;    private long lastOverlayTime = 0;&#10;    private boolean showScreenKeyWasDown = false;&#10;    private GLFWKeyCallback previousKeyCallback = null;&#10;    private GLFWKeyCallback ourKeyCallback = null;&#10;    private long lastWindowHandle = 0;&#10;&#10;    @Override&#10;    public void onInitializeClient() {&#10;        // Ensure configuration is loaded (creates config file if missing)&#10;        try { ColorConfig.load(); } catch (Throwable ignored) {}&#10;        // Create a KeyBinding in a way that tolerates signature changes across Minecraft versions.&#10;        KEY_SHOW_SCREEN = createKeyBindingTolerant(&quot;key.color.show_current_screen&quot;, GLFW.GLFW_KEY_H, &quot;key.categories.color&quot;);&#10;&#10;    }&#10;&#10;    // Helper: construct a KeyBinding in a tolerant way (try normal constructor, fall back to reflective discovery)&#10;    private static KeyBinding createKeyBindingTolerant(String id, int keyCode, String category) {&#10;        // First, try the normal explicit constructor (may throw NoSuchMethodError on some runtime mappings)&#10;        try {&#10;            return KeyBindingHelper.registerKeyBinding(new KeyBinding(id, InputUtil.Type.KEYSYM, keyCode, category));&#10;        } catch (NoSuchMethodError | Exception e) {&#10;            // Fallback: try to reflectively find a compatible constructor and instantiate it&#10;        }&#10;&#10;        try {&#10;            Class&lt;?&gt; kbClass = KeyBinding.class;&#10;            for (Constructor&lt;?&gt; ctor : kbClass.getDeclaredConstructors()) {&#10;                Class&lt;?&gt;[] params = ctor.getParameterTypes();&#10;                if (params.length != 4) continue;&#10;&#10;                Object[] args = new Object[4];&#10;                // first param -&gt; id&#10;                args[0] = id;&#10;                // find int param index&#10;                int intIdx = -1;&#10;                for (int i = 0; i &lt; 4; i++) if (params[i].isPrimitive() &amp;&amp; params[i] == int.class) { intIdx = i; break; }&#10;                if (intIdx == -1) continue;&#10;                args[intIdx] = keyCode;&#10;&#10;                // fill remaining params&#10;                for (int i = 0; i &lt; 4; i++) {&#10;                    if (i == 0 || i == intIdx) continue;&#10;                    if (params[i].isAssignableFrom(String.class)) {&#10;                        args[i] = category;&#10;                        continue;&#10;                    }&#10;                    // If it's an enum (likely InputUtil.Type), try to find a KEYSYM constant or fallback to first&#10;                    if (params[i].isEnum()) {&#10;                        Object[] consts = params[i].getEnumConstants();&#10;                        Object pick = null;&#10;                        for (Object c : consts) {&#10;                            if (c.toString().equals(&quot;KEYSYM&quot;) || c.toString().equals(&quot;KEYSYM&quot;)) { pick = c; break; }&#10;                        }&#10;                        if (pick == null &amp;&amp; consts.length &gt; 0) pick = consts[0];&#10;                        args[i] = pick;&#10;                        continue;&#10;                    }&#10;                    // Last resort: try null (some constructors accept null)&#10;                    args[i] = null;&#10;                }&#10;&#10;                try {&#10;                    ctor.setAccessible(true);&#10;                    Object inst = ctor.newInstance(args);&#10;                    if (inst instanceof KeyBinding) {&#10;                        return KeyBindingHelper.registerKeyBinding((KeyBinding) inst);&#10;                    }&#10;                } catch (Throwable ignored) {&#10;                }&#10;            }&#10;        } catch (Throwable ignored) {}&#10;&#10;        // If all else fails, return a dummy registered keybinding by constructing a simple one via the minimal available API.&#10;        try {&#10;            // As a last fallback, register a keybinding via KeyBindingHelper with reflection creating a proxy-like object.&#10;            // Attempt to create using the constructor (String, int) if it exists.&#10;            Class&lt;?&gt; kbClass = KeyBinding.class;&#10;            for (Constructor&lt;?&gt; ctor : kbClass.getDeclaredConstructors()) {&#10;                Class&lt;?&gt;[] params = ctor.getParameterTypes();&#10;                if (params.length == 2 &amp;&amp; params[0] == String.class &amp;&amp; params[1] == int.class) {&#10;                    Object inst = ctor.newInstance(id, keyCode);&#10;                    if (inst instanceof KeyBinding) return KeyBindingHelper.registerKeyBinding((KeyBinding) inst);&#10;                }&#10;            }&#10;        } catch (Throwable ignored) {}&#10;&#10;        // Unable to construct a KeyBinding safely; return null (GLFW callback still provides functionality).&#10;        return null;&#10;    }&#10;&#10;    private void openAxiomScreen() {&#10;        MinecraftClient mc = MinecraftClient.getInstance();&#10;        // Run on client thread&#10;        mc.execute(() -&gt; {&#10;            boolean opened = false;&#10;            for (String candidate : AXIOM_SCREEN_CANDIDATES) {&#10;                try {&#10;                    Class&lt;?&gt; cls = Class.forName(candidate);&#10;&#10;                    // If this candidate looks like the CreativeColour/CreativeColor screen, ensure vanilla creative inventory screen is open&#10;                    boolean isCreativeColourCandidate = candidate.endsWith(&quot;CreativeColourScreen&quot;) || candidate.endsWith(&quot;CreativeColorScreen&quot;);&#10;                    if (isCreativeColourCandidate) {&#10;                        try {&#10;                            // Detect mapped or obfuscated creative inventory class, but do NOT try to instantiate it here&#10;                            Class&lt;?&gt; creativeCls = null;&#10;                            try { creativeCls = Class.forName(&quot;net.minecraft.client.gui.screen.ingame.CreativeInventoryScreen&quot;); } catch (ClassNotFoundException ignored) {}&#10;                            if (creativeCls == null) {&#10;                                try { creativeCls = Class.forName(&quot;net.minecraft.class_481&quot;); } catch (ClassNotFoundException ignored) {}&#10;                            }&#10;                            if (creativeCls != null) {&#10;                                if (mc.currentScreen == null || !creativeCls.isAssignableFrom(mc.currentScreen.getClass())) {&#10;                                    sendFeedback(mc, &quot;CreativeColourScreen requires the vanilla Creative Inventory open — open it (press 'E' in creative) and press the key again.&quot;);&#10;                                    continue;&#10;                                }&#10;                            } else {&#10;                                // If we can't find the vanilla creative class, fall back to the generic instantiate attempt below&#10;                            }&#10;                        } catch (Throwable ignored) {&#10;                        }&#10;                    }&#10;&#10;                    Object screenObj = null;&#10;                    try {&#10;                        screenObj = tryInstantiate(cls, mc);&#10;                    } catch (Throwable t) {&#10;                        sendFeedback(mc, &quot;Exception while constructing &quot; + cls.getName() + &quot;: &quot; + t.getClass().getSimpleName() + &quot; - &quot; + t.getMessage());&#10;                        continue;&#10;                    }&#10;&#10;                    if (screenObj instanceof Screen) {&#10;                        // Extra safety: for CreativeColour/CreativeColorScreen, ensure the internal creativeScreen field is initialized&#10;                        if (isCreativeColourCandidate) {&#10;                            try {&#10;                                java.lang.reflect.Field f = cls.getDeclaredField(&quot;creativeScreen&quot;);&#10;                                f.setAccessible(true);&#10;                                Object creativeScreenField = f.get(screenObj);&#10;                                if (creativeScreenField == null) {&#10;                                    sendFeedback(mc, &quot;Constructed CreativeColourScreen, but its internal creativeScreen is null. Open the vanilla Creative Inventory (press 'E' in creative mode) and try again.&quot;);&#10;                                    continue;&#10;                                }&#10;                            } catch (NoSuchFieldException nsf) {&#10;                                // field not found, proceed anyway&#10;                            }&#10;                        }&#10;&#10;                        mc.setScreen((Screen) screenObj);&#10;                        sendFeedback(mc, &quot;Opened Axiom screen: &quot; + candidate);&#10;                        opened = true;&#10;                        break;&#10;                    } else {&#10;                        if (screenObj == null) {&#10;                            sendFeedback(mc, &quot;Reflection failed to construct a &quot; + candidate + &quot; (result was null).&quot;);&#10;                        } else {&#10;                            sendFeedback(mc, &quot;Reflection created object but it's not a Screen: &quot; + candidate + &quot; -&gt; &quot; + screenObj);&#10;                        }&#10;                    }&#10;                } catch (ClassNotFoundException e) {&#10;                    // ignore and try next&#10;                } catch (Throwable t) {&#10;                    sendFeedback(mc, &quot;Failed to open candidate &quot; + candidate + &quot;: &quot; + t.getClass().getSimpleName() + &quot; - &quot; + t.getMessage());&#10;                }&#10;            }&#10;            if (!opened) {&#10;                sendFeedback(mc, &quot;Could not find or open any Axiom CreativeColourScreen candidate. Is the Axiom mod loaded?&quot;);&#10;            }&#10;        });&#10;    }&#10;&#10;    private void sendFeedback(MinecraftClient mc, String msg) {&#10;        System.out.println(msg);&#10;        try {&#10;            if (mc.player != null &amp;&amp; mc.inGameHud != null) {&#10;                mc.inGameHud.getChatHud().addMessage(Text.literal(&quot;[color] &quot; + msg));&#10;            }&#10;        } catch (Throwable ignored) {&#10;        }&#10;        // Store for overlay&#10;        lastOverlayMessage = msg;&#10;        lastOverlayTime = System.currentTimeMillis();&#10;    }&#10;&#10;    private Object tryInstantiate(Class&lt;?&gt; cls, MinecraftClient mc) {&#10;        String className = cls.getName();&#10;        try {&#10;            // Null checks for player&#10;            if (mc.player == null) {&#10;                sendFeedback(mc, &quot;Player is null, cannot open Axiom screen.&quot;);&#10;                return null;&#10;            }&#10;            // Quick attempt: prefer the known CreativeColour/CreativeColorScreen constructor&#10;            if (className.endsWith(&quot;CreativeColourScreen&quot;) || className.endsWith(&quot;CreativeColorScreen&quot;)) {&#10;                try {&#10;                    // Try to find a 2-arg constructor and only use it if the current screen matches the second parameter&#10;                    for (Constructor&lt;?&gt; ctor : cls.getDeclaredConstructors()) {&#10;                        Class&lt;?&gt;[] params = ctor.getParameterTypes();&#10;                        if (params.length == 2) {&#10;                            Class&lt;?&gt; p0 = params[0];&#10;                            Class&lt;?&gt; p1 = params[1];&#10;                            // check first param can accept mc.player&#10;                            if (mc.player != null &amp;&amp; p0.isAssignableFrom(mc.player.getClass())) {&#10;                                // If the current screen matches the expected second parameter type use it&#10;                                if (mc.currentScreen != null &amp;&amp; p1.isAssignableFrom(mc.currentScreen.getClass())) {&#10;                                    ctor.setAccessible(true);&#10;                                    return ctor.newInstance(mc.player, mc.currentScreen);&#10;                                }&#10;                                // Otherwise, see if passing null is acceptable (some constructors accept null), try that&#10;                                try {&#10;                                    ctor.setAccessible(true);&#10;                                    return ctor.newInstance(mc.player, (Object) null);&#10;                                } catch (Throwable ignored) {&#10;                                    // If that fails, we'll attempt to auto-create a vanilla CreativeInventoryScreen earlier in the caller&#10;                                }&#10;                                // If we couldn't construct with current screen or null, inform user and abort&#10;                                sendFeedback(mc, &quot;CreativeColourScreen requires the vanilla Creative Inventory open — open it (press 'E' in creative) and press the key again.&quot;);&#10;                                return null;&#10;                             }&#10;                         }&#10;                    }&#10;                } catch (Exception ignored) {&#10;                }&#10;            }&#10;&#10;            // Generic: try to find a constructor where we can supply runtime instances&#10;            Object[] candidates = new Object[] { mc.player, mc.player.getInventory(), mc.currentScreen, mc };&#10;&#10;            for (Constructor&lt;?&gt; ctor : cls.getDeclaredConstructors()) {&#10;                try {&#10;                    ctor.setAccessible(true);&#10;                    Class&lt;?&gt;[] params = ctor.getParameterTypes();&#10;                    Object[] args = new Object[params.length];&#10;                    boolean ok = true;&#10;                    for (int i = 0; i &lt; params.length; i++) {&#10;                        Class&lt;?&gt; p = params[i];&#10;                        // primitives&#10;                        if (p.isPrimitive()) {&#10;                            args[i] = defaultFor(p, mc);&#10;                            continue;&#10;                        }&#10;                        boolean found = false;&#10;                        for (Object cand : candidates) {&#10;                            if (cand != null &amp;&amp; p.isAssignableFrom(cand.getClass())) {&#10;                                args[i] = cand;&#10;                                found = true;&#10;                                break;&#10;                            }&#10;                        }&#10;                        if (!found) {&#10;                            // allow null for non-primitive&#10;                            args[i] = null;&#10;                        }&#10;                    }&#10;                    // try instantiate&#10;                    return ctor.newInstance(args);&#10;                } catch (Throwable ignored) {&#10;                }&#10;            }&#10;        } catch (Exception e) {&#10;            // fallback below&#10;        }&#10;&#10;        // If we reach here, no constructor worked — enumerate available constructors for debugging&#10;        StringBuilder sb = new StringBuilder();&#10;        for (Constructor&lt;?&gt; c : cls.getDeclaredConstructors()) {&#10;            sb.append(&quot;(&quot;);&#10;            Class&lt;?&gt;[] params = c.getParameterTypes();&#10;            for (int i = 0; i &lt; params.length; i++) {&#10;                sb.append(params[i].getName());&#10;                if (i &lt; params.length - 1) sb.append(&quot;, &quot;);&#10;            }&#10;            sb.append(&quot;) &quot;);&#10;        }&#10;        sendFeedback(mc, &quot;No suitable constructor found for &quot; + cls.getName() + &quot;. Available: &quot; + sb.toString());&#10;        // Return null to indicate we couldn't instantiate the class instead of throwing; caller will handle feedback.&#10;        return null;&#10;    }&#10;&#10;    private Object defaultFor(Class&lt;?&gt; t, MinecraftClient mc) {&#10;        if (!t.isPrimitive()) {&#10;            // common helpful substitutions&#10;            if (t.isAssignableFrom(Screen.class)) return mc.currentScreen;&#10;            if (t.isAssignableFrom(MinecraftClient.class)) return mc;&#10;            return null;&#10;        }&#10;        // primitives&#10;        if (t == int.class) return 0;&#10;        if (t == long.class) return 0L;&#10;        if (t == short.class) return (short) 0;&#10;        if (t == byte.class) return (byte) 0;&#10;        if (t == float.class) return 0f;&#10;        if (t == double.class) return 0d;&#10;        if (t == boolean.class) return false;&#10;        if (t == char.class) return '\0';&#10;        return 0; // fallback&#10;    }&#10;&#10;    private void showCurrentScreen() {&#10;        MinecraftClient mc = MinecraftClient.getInstance();&#10;        Screen screen = mc.currentScreen;&#10;        String msg;&#10;        if (screen == null) {&#10;            msg = &quot;No screen is currently open.&quot;;&#10;        } else {&#10;            msg = &quot;Current screen: &quot; + screen.getClass().getName();&#10;        }&#10;        sendFeedback(mc, msg);&#10;    }&#10;&#10;    // Helper to get singleton instance&#10;    private static ColorClient instance;&#10;    public ColorClient() { instance = this; }&#10;&#10;    // Public wrapper for external callers (mixins / widgets) to open the Axiom screen&#10;    // This simply defers to the instance method if available and runs safely on the client thread.&#10;    public static void openAxiomScreenStatic() {&#10;        try {&#10;            MinecraftClient mc = MinecraftClient.getInstance();&#10;            if (mc != null) {&#10;                mc.execute(() -&gt; {&#10;                    try {&#10;                        ColorClient inst = instance;&#10;                        if (inst != null) {&#10;                            inst.openAxiomScreen();&#10;                        } else {&#10;                            // instance not yet initialized; log so user/mixins can see what's happening&#10;                            System.out.println(&quot;[color] ColorClient instance not yet initialized when trying to open Axiom screen.&quot;);&#10;                        }&#10;                    } catch (Throwable ignored) {&#10;                    }&#10;                });&#10;            }&#10;        } catch (Throwable ignored) {}&#10;    }&#10;&#10;    // New: open the CreativeGradientScreen (Axiom) similarly&#10;    public static void openGradientScreenStatic() {&#10;        try {&#10;            MinecraftClient mc = MinecraftClient.getInstance();&#10;            if (mc != null) {&#10;                mc.execute(() -&gt; {&#10;                    try {&#10;                        ColorClient inst = instance;&#10;                        if (inst != null) {&#10;                            inst.openGradientScreen();&#10;                        } else {&#10;                            System.out.println(&quot;[color] ColorClient instance not yet initialized when trying to open Gradient screen.&quot;);&#10;                        }&#10;                    } catch (Throwable ignored) {&#10;                    }&#10;                });&#10;            }&#10;        } catch (Throwable ignored) {}&#10;    }&#10;&#10;    // Instance method to attempt to construct and open the CreativeGradientScreen reflectively&#10;    private void openGradientScreen() {&#10;        MinecraftClient mc = MinecraftClient.getInstance();&#10;        if (mc == null) return;&#10;        mc.execute(() -&gt; {&#10;            boolean opened = false;&#10;            String candidate = &quot;com.moulberry.axiom.screen.CreativeGradientScreen&quot;;&#10;            try {&#10;                Class&lt;?&gt; cls = Class.forName(candidate);&#10;                Object screenObj = null;&#10;                try {&#10;                    screenObj = tryInstantiate(cls, mc);&#10;                } catch (Throwable t) {&#10;                    sendFeedback(mc, &quot;Exception while constructing &quot; + candidate + &quot;: &quot; + t.getClass().getSimpleName() + &quot; - &quot; + t.getMessage());&#10;                }&#10;                if (screenObj instanceof net.minecraft.client.gui.screen.Screen) {&#10;                    mc.setScreen((net.minecraft.client.gui.screen.Screen) screenObj);&#10;                    sendFeedback(mc, &quot;Opened Axiom screen: &quot; + candidate);&#10;                    opened = true;&#10;                } else {&#10;                    if (screenObj == null) sendFeedback(mc, &quot;Reflection failed to construct a &quot; + candidate + &quot; (result was null).&quot;);&#10;                    else sendFeedback(mc, &quot;Reflection created object but it's not a Screen: &quot; + candidate + &quot; -&gt; &quot; + screenObj);&#10;                }&#10;            } catch (ClassNotFoundException e) {&#10;                sendFeedback(mc, &quot;Axiom CreativeGradientScreen class not found. Is the Axiom mod installed?&quot;);&#10;            } catch (Throwable t) {&#10;                sendFeedback(mc, &quot;Failed to open gradient screen: &quot; + t.getClass().getSimpleName() + &quot; - &quot; + t.getMessage());&#10;            }&#10;            if (!opened) {&#10;                // no further action&#10;            }&#10;        });&#10;    }&#10;&#10;    // Single getInstance definition&#10;    private static ColorClient getInstance() { return instance; }&#10;}&#10;" />
              <option name="updatedContent" value="package org.lassilos.color.client;&#10;&#10;import net.fabricmc.api.ClientModInitializer;&#10;import net.fabricmc.fabric.api.client.event.lifecycle.v1.ClientTickEvents;&#10;import net.fabricmc.fabric.api.client.keybinding.v1.KeyBindingHelper;&#10;import net.fabricmc.fabric.api.client.rendering.v1.HudRenderCallback;&#10;import net.minecraft.client.MinecraftClient;&#10;import net.minecraft.client.gui.screen.Screen;&#10;import net.minecraft.client.option.KeyBinding;&#10;import net.minecraft.client.util.InputUtil;&#10;import net.minecraft.text.Text;&#10;import org.lwjgl.glfw.GLFW;&#10;import org.lwjgl.glfw.GLFWKeyCallback;&#10;&#10;import java.lang.reflect.Constructor;&#10;&#10;public class ColorClient implements ClientModInitializer {&#10;&#10;    private static KeyBinding KEY_SHOW_SCREEN;&#10;    private static KeyBinding KEY_DEBUG_O;&#10;    // Try multiple plausible Axiom class names (UK/US spellings and picker variants)&#10;    private static final String[] AXIOM_SCREEN_CANDIDATES = new String[] {&#10;            &quot;com.moulberry.axiom.screen.CreativeColourScreen&quot;,&#10;            &quot;com.moulberry.axiom.screen.CreativeColorScreen&quot;,&#10;            &quot;com.moulberry.axiom.screen.BlockColourPickerScreen&quot;,&#10;            &quot;com.moulberry.axiom.screen.BlockColorPickerScreen&quot;,&#10;            &quot;com.moulberry.axiom.screen.CreativeColourPickerScreen&quot;,&#10;            &quot;com.moulberry.axiom.screen.CreativeColorPickerScreen&quot;&#10;    };&#10;&#10;    private String lastOverlayMessage = null;&#10;    private long lastOverlayTime = 0;&#10;    private boolean showScreenKeyWasDown = false;&#10;    private boolean showDebugKeyWasDown = false;&#10;    private GLFWKeyCallback previousKeyCallback = null;&#10;    private GLFWKeyCallback ourKeyCallback = null;&#10;    private long lastWindowHandle = 0;&#10;&#10;    @Override&#10;    public void onInitializeClient() {&#10;        // Ensure configuration is loaded (creates config file if missing)&#10;        try { ColorConfig.load(); } catch (Throwable ignored) {}&#10;        // Create a KeyBinding in a way that tolerates signature changes across Minecraft versions.&#10;        KEY_SHOW_SCREEN = createKeyBindingTolerant(&quot;key.color.show_current_screen&quot;, GLFW.GLFW_KEY_H, &quot;key.categories.color&quot;);&#10;        // Debug 'O' key that prints the current screen; can be disabled via config&#10;        KEY_DEBUG_O = createKeyBindingTolerant(&quot;key.color.debug_print_screen&quot;, GLFW.GLFW_KEY_O, &quot;key.categories.color&quot;);&#10;&#10;    }&#10;&#10;    // Helper: construct a KeyBinding in a tolerant way (try normal constructor, fall back to reflective discovery)&#10;    private static KeyBinding createKeyBindingTolerant(String id, int keyCode, String category) {&#10;        // First, try the normal explicit constructor (may throw NoSuchMethodError on some runtime mappings)&#10;        try {&#10;            return KeyBindingHelper.registerKeyBinding(new KeyBinding(id, InputUtil.Type.KEYSYM, keyCode, category));&#10;        } catch (NoSuchMethodError | Exception e) {&#10;            // Fallback: try to reflectively find a compatible constructor and instantiate it&#10;        }&#10;&#10;        try {&#10;            Class&lt;?&gt; kbClass = KeyBinding.class;&#10;            for (Constructor&lt;?&gt; ctor : kbClass.getDeclaredConstructors()) {&#10;                Class&lt;?&gt;[] params = ctor.getParameterTypes();&#10;                if (params.length != 4) continue;&#10;&#10;                Object[] args = new Object[4];&#10;                // first param -&gt; id&#10;                args[0] = id;&#10;                // find int param index&#10;                int intIdx = -1;&#10;                for (int i = 0; i &lt; 4; i++) if (params[i].isPrimitive() &amp;&amp; params[i] == int.class) { intIdx = i; break; }&#10;                if (intIdx == -1) continue;&#10;                args[intIdx] = keyCode;&#10;&#10;                // fill remaining params&#10;                for (int i = 0; i &lt; 4; i++) {&#10;                    if (i == 0 || i == intIdx) continue;&#10;                    if (params[i].isAssignableFrom(String.class)) {&#10;                        args[i] = category;&#10;                        continue;&#10;                    }&#10;                    // If it's an enum (likely InputUtil.Type), try to find a KEYSYM constant or fallback to first&#10;                    if (params[i].isEnum()) {&#10;                        Object[] consts = params[i].getEnumConstants();&#10;                        Object pick = null;&#10;                        for (Object c : consts) {&#10;                            if (c.toString().equals(&quot;KEYSYM&quot;) || c.toString().equals(&quot;KEYSYM&quot;)) { pick = c; break; }&#10;                        }&#10;                        if (pick == null &amp;&amp; consts.length &gt; 0) pick = consts[0];&#10;                        args[i] = pick;&#10;                        continue;&#10;                    }&#10;                    // Last resort: try null (some constructors accept null)&#10;                    args[i] = null;&#10;                }&#10;&#10;                try {&#10;                    ctor.setAccessible(true);&#10;                    Object inst = ctor.newInstance(args);&#10;                    if (inst instanceof KeyBinding) {&#10;                        return KeyBindingHelper.registerKeyBinding((KeyBinding) inst);&#10;                    }&#10;                } catch (Throwable ignored) {&#10;                }&#10;            }&#10;        } catch (Throwable ignored) {}&#10;&#10;        // If all else fails, return a dummy registered keybinding by constructing a simple one via the minimal available API.&#10;        try {&#10;            // As a last fallback, register a keybinding via KeyBindingHelper with reflection creating a proxy-like object.&#10;            // Attempt to create using the constructor (String, int) if it exists.&#10;            Class&lt;?&gt; kbClass = KeyBinding.class;&#10;            for (Constructor&lt;?&gt; ctor : kbClass.getDeclaredConstructors()) {&#10;                Class&lt;?&gt;[] params = ctor.getParameterTypes();&#10;                if (params.length == 2 &amp;&amp; params[0] == String.class &amp;&amp; params[1] == int.class) {&#10;                    Object inst = ctor.newInstance(id, keyCode);&#10;                    if (inst instanceof KeyBinding) return KeyBindingHelper.registerKeyBinding((KeyBinding) inst);&#10;                }&#10;            }&#10;        } catch (Throwable ignored) {}&#10;&#10;        // Unable to construct a KeyBinding safely; return null (GLFW callback still provides functionality).&#10;        return null;&#10;    }&#10;&#10;    private void openAxiomScreen() {&#10;        MinecraftClient mc = MinecraftClient.getInstance();&#10;        // Run on client thread&#10;        mc.execute(() -&gt; {&#10;            boolean opened = false;&#10;            for (String candidate : AXIOM_SCREEN_CANDIDATES) {&#10;                try {&#10;                    Class&lt;?&gt; cls = Class.forName(candidate);&#10;&#10;                    // If this candidate looks like the CreativeColour/CreativeColor screen, ensure vanilla creative inventory screen is open&#10;                    boolean isCreativeColourCandidate = candidate.endsWith(&quot;CreativeColourScreen&quot;) || candidate.endsWith(&quot;CreativeColorScreen&quot;);&#10;                    if (isCreativeColourCandidate) {&#10;                        try {&#10;                            // Detect mapped or obfuscated creative inventory class, but do NOT try to instantiate it here&#10;                            Class&lt;?&gt; creativeCls = null;&#10;                            try { creativeCls = Class.forName(&quot;net.minecraft.client.gui.screen.ingame.CreativeInventoryScreen&quot;); } catch (ClassNotFoundException ignored) {}&#10;                            if (creativeCls == null) {&#10;                                try { creativeCls = Class.forName(&quot;net.minecraft.class_481&quot;); } catch (ClassNotFoundException ignored) {}&#10;                            }&#10;                            if (creativeCls != null) {&#10;                                if (mc.currentScreen == null || !creativeCls.isAssignableFrom(mc.currentScreen.getClass())) {&#10;                                    sendFeedback(mc, &quot;CreativeColourScreen requires the vanilla Creative Inventory open — open it (press 'E' in creative) and press the key again.&quot;);&#10;                                    continue;&#10;                                }&#10;                            } else {&#10;                                // If we can't find the vanilla creative class, fall back to the generic instantiate attempt below&#10;                            }&#10;                        } catch (Throwable ignored) {&#10;                        }&#10;                    }&#10;&#10;                    Object screenObj = null;&#10;                    try {&#10;                        screenObj = tryInstantiate(cls, mc);&#10;                    } catch (Throwable t) {&#10;                        sendFeedback(mc, &quot;Exception while constructing &quot; + cls.getName() + &quot;: &quot; + t.getClass().getSimpleName() + &quot; - &quot; + t.getMessage());&#10;                        continue;&#10;                    }&#10;&#10;                    if (screenObj instanceof Screen) {&#10;                        // Extra safety: for CreativeColour/CreativeColorScreen, ensure the internal creativeScreen field is initialized&#10;                        if (isCreativeColourCandidate) {&#10;                            try {&#10;                                java.lang.reflect.Field f = cls.getDeclaredField(&quot;creativeScreen&quot;);&#10;                                f.setAccessible(true);&#10;                                Object creativeScreenField = f.get(screenObj);&#10;                                if (creativeScreenField == null) {&#10;                                    sendFeedback(mc, &quot;Constructed CreativeColourScreen, but its internal creativeScreen is null. Open the vanilla Creative Inventory (press 'E' in creative mode) and try again.&quot;);&#10;                                    continue;&#10;                                }&#10;                            } catch (NoSuchFieldException nsf) {&#10;                                // field not found, proceed anyway&#10;                            }&#10;                        }&#10;&#10;                        mc.setScreen((Screen) screenObj);&#10;                        sendFeedback(mc, &quot;Opened Axiom screen: &quot; + candidate);&#10;                        opened = true;&#10;                        break;&#10;                    } else {&#10;                        if (screenObj == null) {&#10;                            sendFeedback(mc, &quot;Reflection failed to construct a &quot; + candidate + &quot; (result was null).&quot;);&#10;                        } else {&#10;                            sendFeedback(mc, &quot;Reflection created object but it's not a Screen: &quot; + candidate + &quot; -&gt; &quot; + screenObj);&#10;                        }&#10;                    }&#10;                } catch (ClassNotFoundException e) {&#10;                    // ignore and try next&#10;                } catch (Throwable t) {&#10;                    sendFeedback(mc, &quot;Failed to open candidate &quot; + candidate + &quot;: &quot; + t.getClass().getSimpleName() + &quot; - &quot; + t.getMessage());&#10;                }&#10;            }&#10;            if (!opened) {&#10;                sendFeedback(mc, &quot;Could not find or open any Axiom CreativeColourScreen candidate. Is the Axiom mod loaded?&quot;);&#10;            }&#10;        });&#10;    }&#10;&#10;    private void sendFeedback(MinecraftClient mc, String msg) {&#10;        System.out.println(msg);&#10;        try {&#10;            if (mc.player != null &amp;&amp; mc.inGameHud != null) {&#10;                mc.inGameHud.getChatHud().addMessage(Text.literal(&quot;[color] &quot; + msg));&#10;            }&#10;        } catch (Throwable ignored) {&#10;        }&#10;        // Store for overlay&#10;        lastOverlayMessage = msg;&#10;        lastOverlayTime = System.currentTimeMillis();&#10;    }&#10;&#10;    private Object tryInstantiate(Class&lt;?&gt; cls, MinecraftClient mc) {&#10;        String className = cls.getName();&#10;        try {&#10;            // Null checks for player&#10;            if (mc.player == null) {&#10;                sendFeedback(mc, &quot;Player is null, cannot open Axiom screen.&quot;);&#10;                return null;&#10;            }&#10;            // Quick attempt: prefer the known CreativeColour/CreativeColorScreen constructor&#10;            if (className.endsWith(&quot;CreativeColourScreen&quot;) || className.endsWith(&quot;CreativeColorScreen&quot;)) {&#10;                try {&#10;                    // Try to find a 2-arg constructor and only use it if the current screen matches the second parameter&#10;                    for (Constructor&lt;?&gt; ctor : cls.getDeclaredConstructors()) {&#10;                        Class&lt;?&gt;[] params = ctor.getParameterTypes();&#10;                        if (params.length == 2) {&#10;                            Class&lt;?&gt; p0 = params[0];&#10;                            Class&lt;?&gt; p1 = params[1];&#10;                            // check first param can accept mc.player&#10;                            if (mc.player != null &amp;&amp; p0.isAssignableFrom(mc.player.getClass())) {&#10;                                // If the current screen matches the expected second parameter type use it&#10;                                if (mc.currentScreen != null &amp;&amp; p1.isAssignableFrom(mc.currentScreen.getClass())) {&#10;                                    ctor.setAccessible(true);&#10;                                    return ctor.newInstance(mc.player, mc.currentScreen);&#10;                                }&#10;                                // Otherwise, see if passing null is acceptable (some constructors accept null), try that&#10;                                try {&#10;                                    ctor.setAccessible(true);&#10;                                    return ctor.newInstance(mc.player, (Object) null);&#10;                                } catch (Throwable ignored) {&#10;                                    // If that fails, we'll attempt to auto-create a vanilla CreativeInventoryScreen earlier in the caller&#10;                                }&#10;                                // If we couldn't construct with current screen or null, inform user and abort&#10;                                sendFeedback(mc, &quot;CreativeColourScreen requires the vanilla Creative Inventory open — open it (press 'E' in creative) and press the key again.&quot;);&#10;                                return null;&#10;                             }&#10;                         }&#10;                    }&#10;                } catch (Exception ignored) {&#10;                }&#10;            }&#10;&#10;            // Generic: try to find a constructor where we can supply runtime instances&#10;            Object[] candidates = new Object[] { mc.player, mc.player.getInventory(), mc.currentScreen, mc };&#10;&#10;            for (Constructor&lt;?&gt; ctor : cls.getDeclaredConstructors()) {&#10;                try {&#10;                    ctor.setAccessible(true);&#10;                    Class&lt;?&gt;[] params = ctor.getParameterTypes();&#10;                    Object[] args = new Object[params.length];&#10;                    boolean ok = true;&#10;                    for (int i = 0; i &lt; params.length; i++) {&#10;                        Class&lt;?&gt; p = params[i];&#10;                        // primitives&#10;                        if (p.isPrimitive()) {&#10;                            args[i] = defaultFor(p, mc);&#10;                            continue;&#10;                        }&#10;                        boolean found = false;&#10;                        for (Object cand : candidates) {&#10;                            if (cand != null &amp;&amp; p.isAssignableFrom(cand.getClass())) {&#10;                                args[i] = cand;&#10;                                found = true;&#10;                                break;&#10;                            }&#10;                        }&#10;                        if (!found) {&#10;                            // allow null for non-primitive&#10;                            args[i] = null;&#10;                        }&#10;                    }&#10;                    // try instantiate&#10;                    return ctor.newInstance(args);&#10;                } catch (Throwable ignored) {&#10;                }&#10;            }&#10;        } catch (Exception e) {&#10;            // fallback below&#10;        }&#10;&#10;        // If we reach here, no constructor worked — enumerate available constructors for debugging&#10;        StringBuilder sb = new StringBuilder();&#10;        for (Constructor&lt;?&gt; c : cls.getDeclaredConstructors()) {&#10;            sb.append(&quot;(&quot;);&#10;            Class&lt;?&gt;[] params = c.getParameterTypes();&#10;            for (int i = 0; i &lt; params.length; i++) {&#10;                sb.append(params[i].getName());&#10;                if (i &lt; params.length - 1) sb.append(&quot;, &quot;);&#10;            }&#10;            sb.append(&quot;) &quot;);&#10;        }&#10;        sendFeedback(mc, &quot;No suitable constructor found for &quot; + cls.getName() + &quot;. Available: &quot; + sb.toString());&#10;        // Return null to indicate we couldn't instantiate the class instead of throwing; caller will handle feedback.&#10;        return null;&#10;    }&#10;&#10;    private Object defaultFor(Class&lt;?&gt; t, MinecraftClient mc) {&#10;        if (!t.isPrimitive()) {&#10;            // common helpful substitutions&#10;            if (t.isAssignableFrom(Screen.class)) return mc.currentScreen;&#10;            if (t.isAssignableFrom(MinecraftClient.class)) return mc;&#10;            return null;&#10;        }&#10;        // primitives&#10;        if (t == int.class) return 0;&#10;        if (t == long.class) return 0L;&#10;        if (t == short.class) return (short) 0;&#10;        if (t == byte.class) return (byte) 0;&#10;        if (t == float.class) return 0f;&#10;        if (t == double.class) return 0d;&#10;        if (t == boolean.class) return false;&#10;        if (t == char.class) return '\0';&#10;        return 0; // fallback&#10;    }&#10;&#10;    private void showCurrentScreen() {&#10;        MinecraftClient mc = MinecraftClient.getInstance();&#10;        Screen screen = mc.currentScreen;&#10;        String msg;&#10;        if (screen == null) {&#10;            msg = &quot;No screen is currently open.&quot;;&#10;        } else {&#10;            msg = &quot;Current screen: &quot; + screen.getClass().getName();&#10;        }&#10;        sendFeedback(mc, msg);&#10;    }&#10;&#10;    // Helper to get singleton instance&#10;    private static ColorClient instance;&#10;    public ColorClient() { instance = this; }&#10;&#10;    // Public wrapper for external callers (mixins / widgets) to open the Axiom screen&#10;    // This simply defers to the instance method if available and runs safely on the client thread.&#10;    public static void openAxiomScreenStatic() {&#10;        try {&#10;            MinecraftClient mc = MinecraftClient.getInstance();&#10;            if (mc != null) {&#10;                mc.execute(() -&gt; {&#10;                    try {&#10;                        ColorClient inst = instance;&#10;                        if (inst != null) {&#10;                            inst.openAxiomScreen();&#10;                        } else {&#10;                            // instance not yet initialized; log so user/mixins can see what's happening&#10;                            System.out.println(&quot;[color] ColorClient instance not yet initialized when trying to open Axiom screen.&quot;);&#10;                        }&#10;                    } catch (Throwable ignored) {&#10;                    }&#10;                });&#10;            }&#10;        } catch (Throwable ignored) {}&#10;    }&#10;&#10;    // New: open the CreativeGradientScreen (Axiom) similarly&#10;    public static void openGradientScreenStatic() {&#10;        try {&#10;            MinecraftClient mc = MinecraftClient.getInstance();&#10;            if (mc != null) {&#10;                mc.execute(() -&gt; {&#10;                    try {&#10;                        ColorClient inst = instance;&#10;                        if (inst != null) {&#10;                            inst.openGradientScreen();&#10;                        } else {&#10;                            System.out.println(&quot;[color] ColorClient instance not yet initialized when trying to open Gradient screen.&quot;);&#10;                        }&#10;                    } catch (Throwable ignored) {&#10;                    }&#10;                });&#10;            }&#10;        } catch (Throwable ignored) {}&#10;    }&#10;&#10;    // Instance method to attempt to construct and open the CreativeGradientScreen reflectively&#10;    private void openGradientScreen() {&#10;        MinecraftClient mc = MinecraftClient.getInstance();&#10;        if (mc == null) return;&#10;        mc.execute(() -&gt; {&#10;            boolean opened = false;&#10;            String candidate = &quot;com.moulberry.axiom.screen.CreativeGradientScreen&quot;;&#10;            try {&#10;                Class&lt;?&gt; cls = Class.forName(candidate);&#10;                Object screenObj = null;&#10;                try {&#10;                    screenObj = tryInstantiate(cls, mc);&#10;                } catch (Throwable t) {&#10;                    sendFeedback(mc, &quot;Exception while constructing &quot; + candidate + &quot;: &quot; + t.getClass().getSimpleName() + &quot; - &quot; + t.getMessage());&#10;                }&#10;                if (screenObj instanceof net.minecraft.client.gui.screen.Screen) {&#10;                    mc.setScreen((net.minecraft.client.gui.screen.Screen) screenObj);&#10;                    sendFeedback(mc, &quot;Opened Axiom screen: &quot; + candidate);&#10;                    opened = true;&#10;                } else {&#10;                    if (screenObj == null) sendFeedback(mc, &quot;Reflection failed to construct a &quot; + candidate + &quot; (result was null).&quot;);&#10;                    else sendFeedback(mc, &quot;Reflection created object but it's not a Screen: &quot; + candidate + &quot; -&gt; &quot; + screenObj);&#10;                }&#10;            } catch (ClassNotFoundException e) {&#10;                sendFeedback(mc, &quot;Axiom CreativeGradientScreen class not found. Is the Axiom mod installed?&quot;);&#10;            } catch (Throwable t) {&#10;                sendFeedback(mc, &quot;Failed to open gradient screen: &quot; + t.getClass().getSimpleName() + &quot; - &quot; + t.getMessage());&#10;            }&#10;            if (!opened) {&#10;                // no further action&#10;            }&#10;        });&#10;    }&#10;&#10;    // Single getInstance definition&#10;    private static ColorClient getInstance() { return instance; }&#10;&#10;    // New: GLFW key callback for ColorClient (install early in onInitializeClient)&#10;    private void installKeyCallback() {&#10;        MinecraftClient client = MinecraftClient.getInstance();&#10;        if (client == null) return;&#10;        lastWindowHandle = client.getWindow().getHandle();&#10;        previousKeyCallback = GLFW.glfwSetKeyCallback(lastWindowHandle, new GLFWKeyCallback() {&#10;            @Override&#10;            public void invoke(long window, int key, int scancode, int action, int mods) {&#10;                // Ignore if not for this window&#10;                if (window != lastWindowHandle) return;&#10;&#10;                // Debug: print key events&#10;                // System.out.println(&quot;Key: &quot; + key + &quot; Scancode: &quot; + scancode + &quot; Action: &quot; + action + &quot; Mods: &quot; + mods);&#10;&#10;                // Handle key actions&#10;                if (action == GLFW.GLFW_PRESS || action == GLFW.GLFW_REPEAT) {&#10;                    // Show current screen (overlay/chat)&#10;                    if (key == GLFW.GLFW_KEY_H) {&#10;                        MinecraftClient mc = MinecraftClient.getInstance();&#10;                        if (mc != null) mc.execute(() -&gt; {&#10;                            try {&#10;                                ColorClient inst = getInstance();&#10;                                if (inst != null) inst.showCurrentScreen();&#10;                            } catch (Throwable ignored) {}&#10;                        });&#10;                    }&#10;                    // Debug 'O' key: print current screen if enabled in config&#10;                    if (key == GLFW.GLFW_KEY_O) {&#10;                        MinecraftClient mc = MinecraftClient.getInstance();&#10;                        if (mc != null) mc.execute(() -&gt; {&#10;                            try {&#10;                                if (ColorConfig.isDebugKeyOEnabled()) {&#10;                                    ColorClient inst = getInstance();&#10;                                    if (inst != null) inst.showCurrentScreen();&#10;                                }&#10;                            } catch (Throwable ignored) {}&#10;                        });&#10;                    }&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    // New: poll key states each client tick (safer for keybinding availability)&#10;    ClientTickEvents.END_CLIENT_TICK.register(client -&gt; {&#10;        if (client.world == null) return; // skip if not in a world (e.g., title screen)&#10;&#10;        boolean keyDown;&#10;        try {&#10;            if (client.currentScreen != null &amp;&amp; client.getWindow() != null) {&#10;                long handle = client.getWindow().getHandle();&#10;                keyDown = InputUtil.isKeyPressed(handle, GLFW.GLFW_KEY_H);&#10;            } else {&#10;                keyDown = isShowKeyPressed();&#10;            }&#10;        } catch (Throwable t) {&#10;            keyDown = isShowKeyPressed();&#10;        }&#10;        // Debug 'O' key poll (works when window unavailable via registered keybinding too)&#10;        boolean debugKeyDown;&#10;        try {&#10;            if (client.currentScreen != null &amp;&amp; client.getWindow() != null) {&#10;                long handle = client.getWindow().getHandle();&#10;                debugKeyDown = InputUtil.isKeyPressed(handle, GLFW.GLFW_KEY_O);&#10;            } else {&#10;                debugKeyDown = isDebugKeyPressed();&#10;            }&#10;        } catch (Throwable t) {&#10;            debugKeyDown = isDebugKeyPressed();&#10;        }&#10;        if (keyDown &amp;&amp; !showScreenKeyWasDown) {&#10;            // show current screen to user (overlay/chat)&#10;             showCurrentScreen();&#10;          }&#10;          showScreenKeyWasDown = keyDown;&#10;        if (debugKeyDown &amp;&amp; !showDebugKeyWasDown) {&#10;            if (ColorConfig.isDebugKeyOEnabled()) {&#10;                showCurrentScreen();&#10;            }&#10;        }&#10;        showDebugKeyWasDown = debugKeyDown;&#10;      });&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/client/java/org/lassilos/color/client/ColorConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/client/java/org/lassilos/color/client/ColorConfig.java" />
              <option name="originalContent" value="package org.lassilos.color.client;&#10;&#10;import net.fabricmc.loader.api.FabricLoader;&#10;&#10;import java.io.IOException;&#10;import java.io.InputStream;&#10;import java.io.OutputStream;&#10;import java.nio.file.Files;&#10;import java.nio.file.Path;&#10;import java.util.Properties;&#10;&#10;/**&#10; * Simple properties-based configuration for the Color mod.&#10; * Stores booleans controlling whether the buttons should be shown in singleplayer/multiplayer.&#10; */&#10;public final class ColorConfig {&#10;    private static final String FILE_NAME = &quot;color-config.properties&quot;;&#10;    private static final String KEY_SHOW_SINGLE = &quot;show_in_singleplayer&quot;;&#10;    private static final String KEY_SHOW_MULTI = &quot;show_in_multiplayer&quot;;&#10;&#10;    private static boolean loaded = false;&#10;    private static boolean showInSingleplayer = false; // default: false (preserve current behavior)&#10;    private static boolean showInMultiplayer = true;  // default: true&#10;&#10;    private ColorConfig() {}&#10;&#10;    public static synchronized void load() {&#10;        if (loaded) return;&#10;        Path configDir = FabricLoader.getInstance().getConfigDir();&#10;        Path configFile = configDir.resolve(FILE_NAME);&#10;        Properties p = new Properties();&#10;        if (Files.exists(configFile)) {&#10;            try (InputStream in = Files.newInputStream(configFile)) {&#10;                p.load(in);&#10;            } catch (IOException e) {&#10;                System.out.println(&quot;[color] Failed to read config file: &quot; + e.getMessage());&#10;            }&#10;        }&#10;        // parse properties with safe defaults&#10;        showInSingleplayer = Boolean.parseBoolean(p.getProperty(KEY_SHOW_SINGLE, Boolean.toString(showInSingleplayer)));&#10;        showInMultiplayer = Boolean.parseBoolean(p.getProperty(KEY_SHOW_MULTI, Boolean.toString(showInMultiplayer)));&#10;&#10;        // if config file was missing, write defaults&#10;        if (!Files.exists(configFile)) {&#10;            save();&#10;        }&#10;        loaded = true;&#10;        System.out.println(&quot;[color] Config loaded: showInSingleplayer=&quot; + showInSingleplayer + &quot; showInMultiplayer=&quot; + showInMultiplayer);&#10;    }&#10;&#10;    public static synchronized void save() {&#10;        Path configDir = FabricLoader.getInstance().getConfigDir();&#10;        try {&#10;            Files.createDirectories(configDir);&#10;        } catch (IOException e) {&#10;            System.out.println(&quot;[color] Failed to create config directory: &quot; + e.getMessage());&#10;            return;&#10;        }&#10;        Path configFile = configDir.resolve(FILE_NAME);&#10;        Properties p = new Properties();&#10;        p.setProperty(KEY_SHOW_SINGLE, Boolean.toString(showInSingleplayer));&#10;        p.setProperty(KEY_SHOW_MULTI, Boolean.toString(showInMultiplayer));&#10;        try (OutputStream out = Files.newOutputStream(configFile)) {&#10;            p.store(out, &quot;Color mod configuration: set show_in_singleplayer and show_in_multiplayer to true/false&quot;);&#10;        } catch (IOException e) {&#10;            System.out.println(&quot;[color] Failed to write config file: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private static void ensureLoaded() {&#10;        if (!loaded) load();&#10;    }&#10;&#10;    public static boolean shouldShowInSingleplayer() { ensureLoaded(); return showInSingleplayer; }&#10;    public static boolean shouldShowInMultiplayer() { ensureLoaded(); return showInMultiplayer; }&#10;&#10;    public static synchronized void setShowInSingleplayer(boolean v) { showInSingleplayer = v; save(); }&#10;    public static synchronized void setShowInMultiplayer(boolean v) { showInMultiplayer = v; save(); }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package org.lassilos.color.client;&#10;&#10;import net.fabricmc.loader.api.FabricLoader;&#10;&#10;import java.io.IOException;&#10;import java.io.InputStream;&#10;import java.io.OutputStream;&#10;import java.nio.file.Files;&#10;import java.nio.file.Path;&#10;import java.util.Properties;&#10;&#10;/**&#10; * Simple properties-based configuration for the Color mod.&#10; * Stores booleans controlling whether the buttons should be shown in singleplayer/multiplayer.&#10; */&#10;public final class ColorConfig {&#10;    private static final String FILE_NAME = &quot;color-config.properties&quot;;&#10;    private static final String KEY_SHOW_SINGLE = &quot;show_in_singleplayer&quot;;&#10;    private static final String KEY_SHOW_MULTI = &quot;show_in_multiplayer&quot;;&#10;    private static final String KEY_DEBUG_O_ENABLED = &quot;enable_debug_key_o&quot;;&#10;&#10;    private static boolean loaded = false;&#10;    private static boolean showInSingleplayer = false; // default: false (preserve current behavior)&#10;    private static boolean showInMultiplayer = true;  // default: true&#10;    private static boolean debugKeyOEnabled = true;   // default: true (keep debug behaviour enabled)&#10;&#10;    private ColorConfig() {}&#10;&#10;    public static synchronized void load() {&#10;        if (loaded) return;&#10;        Path configDir = FabricLoader.getInstance().getConfigDir();&#10;        Path configFile = configDir.resolve(FILE_NAME);&#10;        Properties p = new Properties();&#10;        if (Files.exists(configFile)) {&#10;            try (InputStream in = Files.newInputStream(configFile)) {&#10;                p.load(in);&#10;            } catch (IOException e) {&#10;                System.out.println(&quot;[color] Failed to read config file: &quot; + e.getMessage());&#10;            }&#10;        }&#10;        // parse properties with safe defaults&#10;        showInSingleplayer = Boolean.parseBoolean(p.getProperty(KEY_SHOW_SINGLE, Boolean.toString(showInSingleplayer)));&#10;        showInMultiplayer = Boolean.parseBoolean(p.getProperty(KEY_SHOW_MULTI, Boolean.toString(showInMultiplayer)));&#10;        debugKeyOEnabled = Boolean.parseBoolean(p.getProperty(KEY_DEBUG_O_ENABLED, Boolean.toString(debugKeyOEnabled)));&#10;&#10;        // if config file was missing, write defaults&#10;        if (!Files.exists(configFile)) {&#10;            save();&#10;        }&#10;        loaded = true;&#10;        System.out.println(&quot;[color] Config loaded: showInSingleplayer=&quot; + showInSingleplayer + &quot; showInMultiplayer=&quot; + showInMultiplayer);&#10;    }&#10;&#10;    public static synchronized void save() {&#10;        Path configDir = FabricLoader.getInstance().getConfigDir();&#10;        try {&#10;            Files.createDirectories(configDir);&#10;        } catch (IOException e) {&#10;            System.out.println(&quot;[color] Failed to create config directory: &quot; + e.getMessage());&#10;            return;&#10;        }&#10;        Path configFile = configDir.resolve(FILE_NAME);&#10;        Properties p = new Properties();&#10;        p.setProperty(KEY_SHOW_SINGLE, Boolean.toString(showInSingleplayer));&#10;        p.setProperty(KEY_SHOW_MULTI, Boolean.toString(showInMultiplayer));&#10;        p.setProperty(KEY_DEBUG_O_ENABLED, Boolean.toString(debugKeyOEnabled));&#10;        try (OutputStream out = Files.newOutputStream(configFile)) {&#10;            p.store(out, &quot;Color mod configuration: set show_in_singleplayer, show_in_multiplayer, enable_debug_key_o to true/false&quot;);&#10;        } catch (IOException e) {&#10;            System.out.println(&quot;[color] Failed to write config file: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private static void ensureLoaded() {&#10;        if (!loaded) load();&#10;    }&#10;&#10;    public static boolean shouldShowInSingleplayer() { ensureLoaded(); return showInSingleplayer; }&#10;    public static boolean shouldShowInMultiplayer() { ensureLoaded(); return showInMultiplayer; }&#10;    public static boolean isDebugKeyOEnabled() { ensureLoaded(); return debugKeyOEnabled; }&#10;&#10;    public static synchronized void setShowInSingleplayer(boolean v) { showInSingleplayer = v; save(); }&#10;    public static synchronized void setShowInMultiplayer(boolean v) { showInMultiplayer = v; save(); }&#10;    public static synchronized void setDebugKeyOEnabled(boolean v) { debugKeyOEnabled = v; save(); }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>